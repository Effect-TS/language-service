// code fix catchAllToMapError_fix  output for range 768 - 780
import { Effect, pipe } from "effect"

class MyErrorTagged {
  readonly _tag = "MyErrorTagged"
  constructor(readonly cause: unknown) {}
}

class AnotherError {
  readonly _tag = "AnotherError"
  constructor(readonly message: string) {}
}

// Should trigger: catchAll with arrow function returning Effect.fail
export const shouldTriggerArrow = Effect.fail("error").pipe(
  Effect.catch((cause) => Effect.fail(new MyErrorTagged(cause)))
)

// Should trigger: catchAll with arrow function returning Effect.fail (block body)
export const shouldTriggerArrowBlock = Effect.fail("error").pipe(
  Effect.catch((cause) => {
    return Effect.fail(new MyErrorTagged(cause))
  })
)

// Should trigger: pipe style
export const shouldTriggerPipe = pipe(
  Effect.fail("error"),
  Effect.mapError((cause) => new MyErrorTagged(cause))
)

// Should trigger: with function expression
export const shouldTriggerFunctionExpr = Effect.fail("error").pipe(
  Effect.catch(function(cause) {
    return Effect.fail(new MyErrorTagged(cause))
  })
)

// Should NOT trigger: catchAll with logic other than just Effect.fail
export const shouldNotTriggerWithLogic = Effect.fail("error").pipe(
  Effect.catch((cause) => {
    console.log(cause)
    return Effect.fail(new MyErrorTagged(cause))
  })
)

// Should NOT trigger: catchAll returning Effect.succeed
export const shouldNotTriggerSucceed = Effect.fail("error").pipe(
  Effect.catch(() => Effect.succeed(42))
)

// Should NOT trigger: catchAll with Effect.flatMap or other operations
export const shouldNotTriggerChained = Effect.fail("error").pipe(
  Effect.catch((cause) =>
    Effect.fail(new MyErrorTagged(cause)).pipe(
      Effect.tap(() => Effect.void)
    )
  )
)

// Should trigger: simple error wrapping
export const shouldTriggerSimple = Effect.fail("original").pipe(
  Effect.catch((e) => Effect.fail(new AnotherError(String(e))))
)
