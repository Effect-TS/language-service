// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Refactor asyncAwaitToGen > asyncAwaitToGen.ts at 4:28 1`] = `
"// Result of running refactor effect/asyncAwaitToGen at position 4:28
import * as T from "effect/Effect"

export function refactorMe(arg: string) {
    return T.gen(function*() {
        return yield* T.promise(() => Promise.resolve(1))
    })
}
"
`;

exports[`Refactor asyncAwaitToGen > asyncAwaitToGen_anonymous.ts at 4:44 1`] = `
"// Result of running refactor effect/asyncAwaitToGen at position 4:44
import * as Effect from "effect/Effect"

const asyncFunctionDeclaration = function() {
    return Effect.gen(function*() {
        const response = yield* Effect.promise(() => fetch("test"))
        if (response.ok) {
            const y = yield* Effect.promise(() => response.json())
            return y
        }
        return null
    })
}

const asyncArrowFunctionExpression = async () => {
  const response = await fetch("test")
  if (response.ok) {
    const y = await response.json()
    return y
  }
  return null
}
"
`;

exports[`Refactor asyncAwaitToGen > asyncAwaitToGen_anonymous.ts at 13:41 1`] = `
"// Result of running refactor effect/asyncAwaitToGen at position 13:41
import * as Effect from "effect/Effect"

const asyncFunctionDeclaration = async function() {
  const response = await fetch("test")
  if (response.ok) {
    const y = await response.json()
    return y
  }
  return null
}

const asyncArrowFunctionExpression = () => Effect.gen(function*() {
    const response = yield* Effect.promise(() => fetch("test"))
    if (response.ok) {
        const y = yield* Effect.promise(() => response.json())
        return y
    }
    return null
})
"
`;

exports[`Refactor asyncAwaitToGen > asyncAwaitToGen_namedImport.ts at 4:28 1`] = `
"// Result of running refactor effect/asyncAwaitToGen at position 4:28
import { Effect as T } from "effect"

export function refactorMe(arg: string) {
    return T.gen(function*() {
        return yield* T.promise(() => Promise.resolve(1))
    })
}
"
`;

exports[`Refactor asyncAwaitToGen > asyncAwaitToGen_reExport.ts at 4:28 1`] = `
"// Result of running refactor effect/asyncAwaitToGen at position 4:28
import { Eff } from "@/utils/reExport.js"

export function refactorMe(arg: string) {
    return Eff.gen(function*() {
        return yield* Eff.promise(() => Promise.resolve(1))
    })
}
"
`;

exports[`Refactor asyncAwaitToGenTryPromise > asyncAwaitToGenTryPromise.ts at 4:28 1`] = `
"// Result of running refactor effect/asyncAwaitToGenTryPromise at position 4:28
import * as Effect from "effect/Effect"

export function refactorMe(arg: string) {
    return Effect.gen(function*() {
        for (let i = 0; i < 10; i++) {
            yield* Effect.tryPromise({ try: () => Promise.resolve(i), catch: error => ({ _tag: "Error1" as const, error }) })
        }
        return yield* Effect.tryPromise({ try: () => Promise.resolve(arg), catch: error => ({ _tag: "Error2" as const, error }) })
    })
}
"
`;

exports[`Refactor asyncAwaitToGenTryPromise > asyncAwaitToGenTryPromise_anonymous.ts at 4:44 1`] = `
"// Result of running refactor effect/asyncAwaitToGenTryPromise at position 4:44
import * as Effect from "effect/Effect"

const asyncFunctionDeclaration = function() {
    return Effect.gen(function*() {
        const response = yield* Effect.tryPromise({ try: () => fetch("test"), catch: error => ({ _tag: "Error1" as const, error }) })
        if (response.ok) {
            const y = yield* Effect.tryPromise({ try: () => response.json(), catch: error => ({ _tag: "Error2" as const, error }) })
            return y
        }
        return null
    })
}

const asyncArrowFunctionExpression = async () => {
  const response = await fetch("test")
  if (response.ok) {
    const y = await response.json()
    return y
  }
  return null
}
"
`;

exports[`Refactor asyncAwaitToGenTryPromise > asyncAwaitToGenTryPromise_anonymous.ts at 13:41 1`] = `
"// Result of running refactor effect/asyncAwaitToGenTryPromise at position 13:41
import * as Effect from "effect/Effect"

const asyncFunctionDeclaration = async function() {
  const response = await fetch("test")
  if (response.ok) {
    const y = await response.json()
    return y
  }
  return null
}

const asyncArrowFunctionExpression = () => Effect.gen(function*() {
    const response = yield* Effect.tryPromise({ try: () => fetch("test"), catch: error => ({ _tag: "Error1" as const, error }) })
    if (response.ok) {
        const y = yield* Effect.tryPromise({ try: () => response.json(), catch: error => ({ _tag: "Error2" as const, error }) })
        return y
    }
    return null
})
"
`;

exports[`Refactor effectGenToFn > effectGenToFn.ts at 4:30 1`] = `
"// Result of running refactor effect/effectGenToFn at position 4:30
import * as Eff from "effect/Effect"

export const program = Eff.fn(function*() {
    const a = yield* Eff.succeed(1)
    const b = yield* Eff.succeed(2)
    return a + b
})

export const programWithPipes = (fa: number, fb: number) => Eff.gen(function* () {
    const a = yield* Eff.succeed(fa)
    const b = yield* Eff.succeed(fb)
    return a + b
}).pipe(
    Eff.map((a) => a + 1)
)

export function sampleReturns<A extends number, B extends number>(arg1: A, arg2: B) {
  return Eff.gen(function* () {
    const a = yield* Eff.succeed(arg1)
    const b = yield* Eff.succeed(arg2)
    return a + b
  })
}

export const sampleReturnsConciseBody = <A extends number, B extends number>(arg1: A, arg2: B) => Eff.gen(function* () {
  const a = yield* Eff.succeed(arg1)
  const b = yield* Eff.succeed(arg2)
  return a + b
})
"
`;

exports[`Refactor effectGenToFn > effectGenToFn.ts at 4:36 1`] = `
"// Result of running refactor effect/effectGenToFn at position 4:36
import * as Eff from "effect/Effect"

export const program = Eff.fn(function*() {
    const a = yield* Eff.succeed(1)
    const b = yield* Eff.succeed(2)
    return a + b
})

export const programWithPipes = (fa: number, fb: number) => Eff.gen(function* () {
    const a = yield* Eff.succeed(fa)
    const b = yield* Eff.succeed(fb)
    return a + b
}).pipe(
    Eff.map((a) => a + 1)
)

export function sampleReturns<A extends number, B extends number>(arg1: A, arg2: B) {
  return Eff.gen(function* () {
    const a = yield* Eff.succeed(arg1)
    const b = yield* Eff.succeed(arg2)
    return a + b
  })
}

export const sampleReturnsConciseBody = <A extends number, B extends number>(arg1: A, arg2: B) => Eff.gen(function* () {
  const a = yield* Eff.succeed(arg1)
  const b = yield* Eff.succeed(arg2)
  return a + b
})
"
`;

exports[`Refactor effectGenToFn > effectGenToFn.ts at 10:61 1`] = `
"// Result of running refactor effect/effectGenToFn at position 10:61
import * as Eff from "effect/Effect"

export const program = () => Eff.gen(function* () {
    const a = yield* Eff.succeed(1)
    const b = yield* Eff.succeed(2)
    return a + b
  })

export const programWithPipes = Eff.fn(function*(fa: number, fb: number) {
    const a = yield* Eff.succeed(fa)
    const b = yield* Eff.succeed(fb)
    return a + b
}, Eff.map((a) => a + 1))

export function sampleReturns<A extends number, B extends number>(arg1: A, arg2: B) {
  return Eff.gen(function* () {
    const a = yield* Eff.succeed(arg1)
    const b = yield* Eff.succeed(arg2)
    return a + b
  })
}

export const sampleReturnsConciseBody = <A extends number, B extends number>(arg1: A, arg2: B) => Eff.gen(function* () {
  const a = yield* Eff.succeed(arg1)
  const b = yield* Eff.succeed(arg2)
  return a + b
})
"
`;

exports[`Refactor effectGenToFn > effectGenToFn.ts at 10:67 1`] = `
"// Result of running refactor effect/effectGenToFn at position 10:67
import * as Eff from "effect/Effect"

export const program = () => Eff.gen(function* () {
    const a = yield* Eff.succeed(1)
    const b = yield* Eff.succeed(2)
    return a + b
  })

export const programWithPipes = Eff.fn(function*(fa: number, fb: number) {
    const a = yield* Eff.succeed(fa)
    const b = yield* Eff.succeed(fb)
    return a + b
}, Eff.map((a) => a + 1))

export function sampleReturns<A extends number, B extends number>(arg1: A, arg2: B) {
  return Eff.gen(function* () {
    const a = yield* Eff.succeed(arg1)
    const b = yield* Eff.succeed(arg2)
    return a + b
  })
}

export const sampleReturnsConciseBody = <A extends number, B extends number>(arg1: A, arg2: B) => Eff.gen(function* () {
  const a = yield* Eff.succeed(arg1)
  const b = yield* Eff.succeed(arg2)
  return a + b
})
"
`;

exports[`Refactor effectGenToFn > effectGenToFn.ts at 19:10 1`] = `
"// Result of running refactor effect/effectGenToFn at position 19:10
import * as Eff from "effect/Effect"

export const program = () => Eff.gen(function* () {
    const a = yield* Eff.succeed(1)
    const b = yield* Eff.succeed(2)
    return a + b
  })

export const programWithPipes = (fa: number, fb: number) => Eff.gen(function* () {
    const a = yield* Eff.succeed(fa)
    const b = yield* Eff.succeed(fb)
    return a + b
}).pipe(
    Eff.map((a) => a + 1)
)

export const sampleReturns = Eff.fn("sampleReturns")(function* <A extends number, B extends number>(arg1: A, arg2: B) {
    const a = yield* Eff.succeed(arg1)
    const b = yield* Eff.succeed(arg2)
    return a + b
})

export const sampleReturnsConciseBody = <A extends number, B extends number>(arg1: A, arg2: B) => Eff.gen(function* () {
  const a = yield* Eff.succeed(arg1)
  const b = yield* Eff.succeed(arg2)
  return a + b
})
"
`;

exports[`Refactor effectGenToFn > effectGenToFn.ts at 19:16 1`] = `
"// Result of running refactor effect/effectGenToFn at position 19:16
import * as Eff from "effect/Effect"

export const program = () => Eff.gen(function* () {
    const a = yield* Eff.succeed(1)
    const b = yield* Eff.succeed(2)
    return a + b
  })

export const programWithPipes = (fa: number, fb: number) => Eff.gen(function* () {
    const a = yield* Eff.succeed(fa)
    const b = yield* Eff.succeed(fb)
    return a + b
}).pipe(
    Eff.map((a) => a + 1)
)

export const sampleReturns = Eff.fn("sampleReturns")(function* <A extends number, B extends number>(arg1: A, arg2: B) {
    const a = yield* Eff.succeed(arg1)
    const b = yield* Eff.succeed(arg2)
    return a + b
})

export const sampleReturnsConciseBody = <A extends number, B extends number>(arg1: A, arg2: B) => Eff.gen(function* () {
  const a = yield* Eff.succeed(arg1)
  const b = yield* Eff.succeed(arg2)
  return a + b
})
"
`;

exports[`Refactor effectGenToFn > effectGenToFn.ts at 26:99 1`] = `
"// Result of running refactor effect/effectGenToFn at position 26:99
import * as Eff from "effect/Effect"

export const program = () => Eff.gen(function* () {
    const a = yield* Eff.succeed(1)
    const b = yield* Eff.succeed(2)
    return a + b
  })

export const programWithPipes = (fa: number, fb: number) => Eff.gen(function* () {
    const a = yield* Eff.succeed(fa)
    const b = yield* Eff.succeed(fb)
    return a + b
}).pipe(
    Eff.map((a) => a + 1)
)

export function sampleReturns<A extends number, B extends number>(arg1: A, arg2: B) {
  return Eff.gen(function* () {
    const a = yield* Eff.succeed(arg1)
    const b = yield* Eff.succeed(arg2)
    return a + b
  })
}

export const sampleReturnsConciseBody = Eff.fn(function* <A extends number, B extends number>(arg1: A, arg2: B) {
    const a = yield* Eff.succeed(arg1)
    const b = yield* Eff.succeed(arg2)
    return a + b
})
"
`;

exports[`Refactor effectGenToFn > effectGenToFn.ts at 26:104 1`] = `
"// Result of running refactor effect/effectGenToFn at position 26:104
import * as Eff from "effect/Effect"

export const program = () => Eff.gen(function* () {
    const a = yield* Eff.succeed(1)
    const b = yield* Eff.succeed(2)
    return a + b
  })

export const programWithPipes = (fa: number, fb: number) => Eff.gen(function* () {
    const a = yield* Eff.succeed(fa)
    const b = yield* Eff.succeed(fb)
    return a + b
}).pipe(
    Eff.map((a) => a + 1)
)

export function sampleReturns<A extends number, B extends number>(arg1: A, arg2: B) {
  return Eff.gen(function* () {
    const a = yield* Eff.succeed(arg1)
    const b = yield* Eff.succeed(arg2)
    return a + b
  })
}

export const sampleReturnsConciseBody = Eff.fn(function* <A extends number, B extends number>(arg1: A, arg2: B) {
    const a = yield* Eff.succeed(arg1)
    const b = yield* Eff.succeed(arg2)
    return a + b
})
"
`;

exports[`Refactor effectGenToFn > effectGenToFn_classMethod.ts at 6:17 1`] = `
"// Result of running refactor effect/effectGenToFn at position 6:17
import * as Eff from "effect/Effect"

class Test {
  methodReturnsEffect = Eff.fn("methodReturnsEffect")(function*(arg1: number, arg2: number) {
        const a = yield* Eff.succeed(arg1)
        const b = yield* Eff.succeed(arg2)
        return a + b
    })
}
"
`;

exports[`Refactor functionToArrow > functionToArrow.ts at 5:20 1`] = `
"// Result of running refactor effect/functionToArrow at position 5:20
/**
 * Docs
 */
export const myTest = (name: string) => name.length

/**
 * Docs
 */
export function myTest2(name: string) {
  if (name === "LOL") return 42
  return name.length
}

class Sample {
  /**
   * Docs
   */
  test(name: string) {
    return name.length
  }
}
"
`;

exports[`Refactor functionToArrow > functionToArrow.ts at 12:20 1`] = `
"// Result of running refactor effect/functionToArrow at position 12:20
/**
 * Docs
 */
export function myTest(name: string) {
  return name.length
}

/**
 * Docs
 */
export const myTest2 = (name: string) => {
    if (name === "LOL") return 42
    return name.length
}

class Sample {
  /**
   * Docs
   */
  test(name: string) {
    return name.length
  }
}
"
`;

exports[`Refactor functionToArrow > functionToArrow.ts at 21:5 1`] = `
"// Result of running refactor effect/functionToArrow at position 21:5
/**
 * Docs
 */
export function myTest(name: string) {
  return name.length
}

/**
 * Docs
 */
export function myTest2(name: string) {
  if (name === "LOL") return 42
  return name.length
}

class Sample {
    /**
     * Docs
     */
    test = (name: string) => name.length
}
"
`;

exports[`Refactor makeSchemaOpaque > makeSchemaOpaque.ts at 4:17 1`] = `
"// Result of running refactor effect/makeSchemaOpaque at position 4:17
import * as Schema from "effect/Schema"

export const MyStruct_ = Schema.Struct({
    id: Schema.Number,
    name: Schema.String
})

export interface MyStruct extends Schema.Schema.Type<typeof MyStruct_> { }
export interface MyStructEncoded extends Schema.Schema.Encoded<typeof MyStruct_> { }
export type MyStructContext = Schema.Schema.Context<typeof MyStruct_>
export const MyStruct: Schema.Schema<MyStruct, MyStructEncoded, MyStructContext> = MyStruct_
"
`;

exports[`Refactor makeSchemaOpaque > makeSchemaOpaque_shortImport.ts at 4:17 1`] = `
"// Result of running refactor effect/makeSchemaOpaque at position 4:17
import { Schema } from "effect"

export const MyStruct_ = Schema.Struct({
    id: Schema.Number,
    name: Schema.String
})

export interface MyStruct extends Schema.Schema.Type<typeof MyStruct_> { }
export interface MyStructEncoded extends Schema.Schema.Encoded<typeof MyStruct_> { }
export type MyStructContext = Schema.Schema.Context<typeof MyStruct_>
export const MyStruct: Schema.Schema<MyStruct, MyStructEncoded, MyStructContext> = MyStruct_
"
`;

exports[`Refactor makeSchemaOpaque > makeSchemaOpaque_shortImportAlias.ts at 4:17 1`] = `
"// Result of running refactor effect/makeSchemaOpaque at position 4:17
import { Schema as S } from "effect"

export const MyStruct_ = S.Struct({
    id: S.Number,
    name: S.String
})

export interface MyStruct extends S.Schema.Type<typeof MyStruct_> { }
export interface MyStructEncoded extends S.Schema.Encoded<typeof MyStruct_> { }
export type MyStructContext = S.Schema.Context<typeof MyStruct_>
export const MyStruct: S.Schema<MyStruct, MyStructEncoded, MyStructContext> = MyStruct_
"
`;

exports[`Refactor makeSchemaOpaque > makeSchemaOpaque_union.ts at 4:17 1`] = `
"// Result of running refactor effect/makeSchemaOpaque at position 4:17
import * as Schema from "effect/Schema"

export const MyUnion_ = Schema.Union(
    Schema.Literal("A"),
    Schema.Literal("B")
)

export type MyUnion = Schema.Schema.Type<typeof MyUnion_>
export type MyUnionEncoded = Schema.Schema.Encoded<typeof MyUnion_>
export type MyUnionContext = Schema.Schema.Context<typeof MyUnion_>
export const MyUnion: Schema.Schema<MyUnion, MyUnionEncoded, MyUnionContext> = MyUnion_
"
`;

exports[`Refactor makeSchemaOpaqueWithNs > makeSchemaOpaqueWithNs_shortImport.ts at 4:17 1`] = `
"// Result of running refactor effect/makeSchemaOpaqueWithNs at position 4:17
import { Schema } from "effect"

export const MyStruct_ = Schema.Struct({
    id: Schema.Number,
    name: Schema.String
})

export interface MyStruct extends Schema.Schema.Type<typeof MyStruct_> { }
export namespace MyStruct {
    export interface Encoded extends Schema.Schema.Encoded<typeof MyStruct_> { }
    export type Context = Schema.Schema.Context<typeof MyStruct_>
}
export const MyStruct: Schema.Schema<MyStruct, MyStruct.Encoded, MyStruct.Context> = MyStruct_
"
`;

exports[`Refactor pipeableToDatafirst > pipeableToDatafirst.ts at 5:16 1`] = `
"// Result of running refactor effect/pipeableToDatafirst at position 5:16
import * as T from "effect/Effect"
import { pipe } from "effect/Function"

const test = T.map(T.zipRight(T.flatMap(T.succeed("Hello"), (_) => T.log(_)), T.succeed(42)), (_) => _ * 2)

const noDataFirst = (value: string) => <A, E, R>(eff: T.Effect<A, E, R>) => pipe(eff, T.zipLeft(T.log(value)))

const test2 = pipe(
  T.succeed("Hello"),
  T.flatMap((_) => T.log(_)),
  noDataFirst("42")
)

const test3 = pipe(
  T.succeed("Hello"),
  T.flatMap((_) => T.log(_)),
  noDataFirst("a"),
  noDataFirst("b"),
  noDataFirst("c")
)
"
`;

exports[`Refactor pipeableToDatafirst > pipeableToDatafirst.ts at 14:16 1`] = `
"// Result of running refactor effect/pipeableToDatafirst at position 14:16
import * as T from "effect/Effect"
import { pipe } from "effect/Function"

const test = pipe(
  T.succeed("Hello"),
  T.flatMap((_) => T.log(_)),
  T.zipRight(T.succeed(42)),
  T.map((_) => _ * 2)
)

const noDataFirst = (value: string) => <A, E, R>(eff: T.Effect<A, E, R>) => pipe(eff, T.zipLeft(T.log(value)))

const test2 = pipe(T.flatMap(T.succeed("Hello"), (_) => T.log(_)), noDataFirst("42"))

const test3 = pipe(
  T.succeed("Hello"),
  T.flatMap((_) => T.log(_)),
  noDataFirst("a"),
  noDataFirst("b"),
  noDataFirst("c")
)
"
`;

exports[`Refactor pipeableToDatafirst > pipeableToDatafirst.ts at 20:16 1`] = `
"// Result of running refactor effect/pipeableToDatafirst at position 20:16
import * as T from "effect/Effect"
import { pipe } from "effect/Function"

const test = pipe(
  T.succeed("Hello"),
  T.flatMap((_) => T.log(_)),
  T.zipRight(T.succeed(42)),
  T.map((_) => _ * 2)
)

const noDataFirst = (value: string) => <A, E, R>(eff: T.Effect<A, E, R>) => pipe(eff, T.zipLeft(T.log(value)))

const test2 = pipe(
  T.succeed("Hello"),
  T.flatMap((_) => T.log(_)),
  noDataFirst("42")
)

const test3 = pipe(T.flatMap(T.succeed("Hello"), (_) => T.log(_)), noDataFirst("a"),
    noDataFirst("b"),
    noDataFirst("c"))
"
`;

exports[`Refactor removeUnnecessaryEffectGen > removeUnnecessaryEffectGen.ts at 4:22 1`] = `
"// Result of running refactor effect/removeUnnecessaryEffectGen at position 4:22
import * as Effect from "effect/Effect"

export const test1 = Effect.succeed(42)

Effect.gen(function* () {
    return yield* Effect.succeed(42)
})

export const test2 = Effect.gen(function* () {
    return yield* Effect.gen(function* () {
        return yield* Effect.succeed(42)
    })
})

export const test3 = Effect.succeed(42).pipe(
    Effect.andThen((a) => Effect.gen(function* () {
        return yield* Effect.succeed(a)
    })),
)
"
`;

exports[`Refactor removeUnnecessaryEffectGen > removeUnnecessaryEffectGen.ts at 8:1 1`] = `
"// Result of running refactor effect/removeUnnecessaryEffectGen at position 8:1
import * as Effect from "effect/Effect"

export const test1 = Effect.gen(function* () {
    return yield* Effect.succeed(42)
})

Effect.succeed(42)

export const test2 = Effect.gen(function* () {
    return yield* Effect.gen(function* () {
        return yield* Effect.succeed(42)
    })
})

export const test3 = Effect.succeed(42).pipe(
    Effect.andThen((a) => Effect.gen(function* () {
        return yield* Effect.succeed(a)
    })),
)
"
`;

exports[`Refactor removeUnnecessaryEffectGen > removeUnnecessaryEffectGen.ts at 12:22 1`] = `
"// Result of running refactor effect/removeUnnecessaryEffectGen at position 12:22
import * as Effect from "effect/Effect"

export const test1 = Effect.gen(function* () {
    return yield* Effect.succeed(42)
})

Effect.gen(function* () {
    return yield* Effect.succeed(42)
})

export const test2 = Effect.gen(function*() {
    return yield* Effect.succeed(42)
})

export const test3 = Effect.succeed(42).pipe(
    Effect.andThen((a) => Effect.gen(function* () {
        return yield* Effect.succeed(a)
    })),
)
"
`;

exports[`Refactor removeUnnecessaryEffectGen > removeUnnecessaryEffectGen.ts at 13:19 1`] = `
"// Result of running refactor effect/removeUnnecessaryEffectGen at position 13:19
import * as Effect from "effect/Effect"

export const test1 = Effect.gen(function* () {
    return yield* Effect.succeed(42)
})

Effect.gen(function* () {
    return yield* Effect.succeed(42)
})

export const test2 = Effect.gen(function* () {
    return yield* Effect.succeed(42)
})

export const test3 = Effect.succeed(42).pipe(
    Effect.andThen((a) => Effect.gen(function* () {
        return yield* Effect.succeed(a)
    })),
)
"
`;

exports[`Refactor removeUnnecessaryEffectGen > removeUnnecessaryEffectGen.ts at 19:27 1`] = `
"// Result of running refactor effect/removeUnnecessaryEffectGen at position 19:27
import * as Effect from "effect/Effect"

export const test1 = Effect.gen(function* () {
    return yield* Effect.succeed(42)
})

Effect.gen(function* () {
    return yield* Effect.succeed(42)
})

export const test2 = Effect.gen(function* () {
    return yield* Effect.gen(function* () {
        return yield* Effect.succeed(42)
    })
})

export const test3 = Effect.succeed(42).pipe(
    Effect.andThen((a) => Effect.succeed(a)),
)
"
`;

exports[`Refactor toggleLazyConst > toggleLazyConst.ts at 3:7 1`] = `
"// Result of running refactor effect/toggleLazyConst at position 3:7

const test1 = () => 1

const test2 = () => 1

const test3 = () => {
    console.log("Hello")
}
"
`;

exports[`Refactor toggleLazyConst > toggleLazyConst.ts at 3:10 1`] = `
"// Result of running refactor effect/toggleLazyConst at position 3:10

const test1 = () => 1

const test2 = () => 1

const test3 = () => {
    console.log("Hello")
}
"
`;

exports[`Refactor toggleLazyConst > toggleLazyConst.ts at 5:7 1`] = `
"// Result of running refactor effect/toggleLazyConst at position 5:7

const test1 = 1

const test2 = 1

const test3 = () => {
    console.log("Hello")
}
"
`;

exports[`Refactor toggleLazyConst > toggleLazyConst.ts at 5:10 1`] = `
"// Result of running refactor effect/toggleLazyConst at position 5:10

const test1 = 1

const test2 = 1

const test3 = () => {
    console.log("Hello")
}
"
`;

exports[`Refactor toggleLazyConst > toggleLazyConst.ts at 7:10 1`] = `
"// Result of running refactor effect/toggleLazyConst at position 7:10

const test1 = 1

const test2 = () => 1

const test3 = () => {
    console.log("Hello")
}
"
`;

exports[`Refactor toggleReturnTypeAnnotation > toggleReturnTypeAnnotation.ts at 4:32 1`] = `
"// Result of running refactor effect/toggleReturnTypeAnnotation at position 4:32
import * as T from "effect/Effect"

export const test1 = (): T.Effect<number, never, never> => T.succeed(42)

export const test2 = () => (true ? T.succeed(42) : false)

function sillyGenerics<A>(value: A) {
  return T.fail(value)
}

function removeAnnotation():number{
  return 42
}

function removeAnnotationWithSpace(): number {
  return 42
}
"
`;

exports[`Refactor toggleReturnTypeAnnotation > toggleReturnTypeAnnotation.ts at 6:32 1`] = `
"// Result of running refactor effect/toggleReturnTypeAnnotation at position 6:32
import * as T from "effect/Effect"

export const test1 = () => T.succeed(42)

export const test2 = (): false | T.Effect<number, never, never> => (true ? T.succeed(42) : false)

function sillyGenerics<A>(value: A) {
  return T.fail(value)
}

function removeAnnotation():number{
  return 42
}

function removeAnnotationWithSpace(): number {
  return 42
}
"
`;

exports[`Refactor toggleReturnTypeAnnotation > toggleReturnTypeAnnotation.ts at 8:32 1`] = `
"// Result of running refactor effect/toggleReturnTypeAnnotation at position 8:32
import * as T from "effect/Effect"

export const test1 = () => T.succeed(42)

export const test2 = () => (true ? T.succeed(42) : false)

function sillyGenerics<A>(value: A): T.Effect<never, A, never> {
  return T.fail(value)
}

function removeAnnotation():number{
  return 42
}

function removeAnnotationWithSpace(): number {
  return 42
}
"
`;

exports[`Refactor toggleReturnTypeAnnotation > toggleReturnTypeAnnotation.ts at 12:18 1`] = `
"// Result of running refactor effect/toggleReturnTypeAnnotation at position 12:18
import * as T from "effect/Effect"

export const test1 = () => T.succeed(42)

export const test2 = () => (true ? T.succeed(42) : false)

function sillyGenerics<A>(value: A) {
  return T.fail(value)
}

function removeAnnotation(){
  return 42
}

function removeAnnotationWithSpace(): number {
  return 42
}
"
`;

exports[`Refactor toggleReturnTypeAnnotation > toggleReturnTypeAnnotation.ts at 16:18 1`] = `
"// Result of running refactor effect/toggleReturnTypeAnnotation at position 16:18
import * as T from "effect/Effect"

export const test1 = () => T.succeed(42)

export const test2 = () => (true ? T.succeed(42) : false)

function sillyGenerics<A>(value: A) {
  return T.fail(value)
}

function removeAnnotation():number{
  return 42
}

function removeAnnotationWithSpace() {
  return 42
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 4:14 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 4:14
import * as T from "effect/Effect"

export const test1: <A>(value: A) => T.Effect<A> = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 4:16 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 4:16
import * as T from "effect/Effect"

export const test1: <A>(value: A) => T.Effect<A> = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 5:14 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 5:14
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2: T.Effect<never, string, never> = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 5:16 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 5:16
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2: T.Effect<never, string, never> = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 8:14 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 8:14
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3: 42 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 8:16 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 8:16
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3: 42 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 11:14 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 11:14
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4: () => number = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 11:16 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 11:16
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4: () => number = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 12:14 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 12:14
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5: (defect: unknown) => T.Effect<never> = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 12:16 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 12:16
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5: (defect: unknown) => T.Effect<never> = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 14:7 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 14:7
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 14:16 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 14:16
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 15:7 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 15:7
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 15:16 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 15:16
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 20:14 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 20:14
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6: {
    (a: 1): boolean;
    (a: 2): string
} = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 20:16 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 20:16
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6: {
    (a: 1): boolean;
    (a: 2): string
} = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 24:14 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 24:14
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7: {
    (a: 1): boolean;
    (a: 2): string
} = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 24:16 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 24:16
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7: {
    (a: 1): boolean;
    (a: 2): string
} = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 38:14 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 38:14
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8: {
    (a: 1): boolean;
    (b: 2): string;
    (a: 3): number;
    (b: 4): bigint
} = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 38:16 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 38:16
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8: {
    (a: 1): boolean;
    (b: 2): string;
    (a: 3): number;
    (b: 4): bigint
} = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 41:15 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 41:15
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd: "hello" = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 42:12 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 42:12
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 42:15 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 42:15
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove = "hello"
    propAdd = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 43:5 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 43:5
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd: "hello" = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 43:9 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 43:9
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd: "hello" = "hello"
    propRemove: string = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 44:5 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 44:5
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation.ts at 44:9 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 44:9
import * as T from "effect/Effect"

export const test1 = T.succeed
export const test2 = T.fail("LOL")

const predefined = 42
export const test3 = predefined

const callable = () => 42
export const test4 = callable
export const test5 = T.die

const removeAnnotation:number=42
const removeAnnotationWithSpace: number = 42

declare function withOverloads(a: 1): boolean
declare function withOverloads(a: 2): string

export const test6 = withOverloads

declare const functIntersection: ((a: 1) => boolean) & ((a: 2) => string)

export const test7 = functIntersection

declare const intersection1: {
    (a: 1): boolean
    (b: 2): string
}

declare const intersection2: {
    (a: 3): number
    (b: 4): bigint
}

declare function intersect<A, B>(a: A, b: B): A & B

export const test8 = intersect(intersection1, intersection2)

class Test {
    static liveAdd = "hello"
    static liveRemove: string = "hello"
    propAdd = "hello"
    propRemove = "hello"    
}
"
`;

exports[`Refactor toggleTypeAnnotation > toggleTypeAnnotation_schema.ts at 11:15 1`] = `
"// Result of running refactor effect/toggleTypeAnnotation at position 11:15
import * as Schema from "effect/Schema"
import * as ParseResult from "effect/ParseResult"
import * as ParseOption from "effect/SchemaAST"
import * as Effect from "effect/Effect"

class Person extends Schema.TaggedClass<Person>("Person")("Person", {
    name: Schema.NonEmptyString,
    age: Schema.Int
}){
    static decode: (i: { readonly name: string; readonly age: number; readonly _tag: "Person" }, overrideOptions?: ParseOption.ParseOptions) => Effect.Effect<Person, ParseResult.ParseError, never> = Schema.decode(Person)
}
"
`;

exports[`Refactor typeToEffectSchema > typeToEffectSchema.ts at 4:21 1`] = `
"// Result of running refactor effect/typeToEffectSchema at position 4:21
import * as Schema from "effect/Schema"

export const MyStruct = Schema.Struct({
    anyProp: Schema.Any,
    bigintProp: Schema.BigInt,
    booleanProp: Schema.Boolean,
    neverProp: Schema.Never,
    nullProp: Schema.Null,
    numberProp: Schema.Number,
    stringProp: Schema.String,
    undefinedProp: Schema.Undefined,
    unknownProp: Schema.Unknown,
    voidProp: Schema.Void,
    arrayTypeProp: Schema.Array(Schema.String),
    arrayProp: Schema.Array(Schema.String),
    dateProp: Schema.Date,
    trueProp: Schema.Literal(true),
    falseProp: Schema.Literal(false),
    literalProp: Schema.Literal("hello"),
    numericLiteralProp: Schema.Literal(42),
    unionProp: Schema.Union(Schema.String, Schema.Boolean),
    intersectionProp: Schema.Struct({
        a: Schema.String
    }).pipe(Schema.extend(Schema.Struct({
        b: Schema.Number
    }))),
    recordProp: Schema.Record({ key: Schema.String, value: Schema.Number }),
    inlineStruct: Schema.Struct({
        a: Schema.String,
        b: Schema.Number
    }),
    otherReference: MyUnion,
    otherWithArguments:  /* Not supported conversion: MyType<string, boolean> */,
    // single line comment
    prop: Schema.String,
    /**
     * Multiline comment
     */
    prop2: Schema.String
})

export interface MyStruct {
    anyProp: any
    bigintProp: bigint
    booleanProp: boolean
    neverProp: never
    nullProp: null
    numberProp: number
    stringProp: string
    undefinedProp: undefined
    unknownProp: unknown
    voidProp: void
    arrayTypeProp: string[]
    arrayProp: Array<string>
    dateProp: Date
    trueProp: true
    falseProp: false
    literalProp: "hello"
    numericLiteralProp: 42
    unionProp: string | boolean
    intersectionProp: {a: string} & {b: number}
    recordProp: Record<string, number>
    inlineStruct: {a: string, b: number}
    otherReference: MyUnion
    otherWithArguments: MyType<string, boolean>
    // single line comment
    prop: string
    /**
     * Multiline comment
     */
    prop2: string
}

type MyUnion = "A" | "B"
interface MyType<A, B>{
    _A: A
    _B: B
}
"
`;

exports[`Refactor typeToEffectSchema > typeToEffectSchema_conditionalType.ts at 3:15 1`] = `
"// Result of running refactor effect/typeToEffectSchema at position 3:15

export const Test =  /* Not supported conversion: {a: string} extends Record<string, infer T> ? T : never */;

export type Test = {a: string} extends Record<string, infer T> ? T : never
"
`;

exports[`Refactor typeToEffectSchema > typeToEffectSchema_dataTypes.ts at 8:23 1`] = `
"// Result of running refactor effect/typeToEffectSchema at position 8:23
import * as Option from "effect/Option"
import * as Either from "effect/Either"
import * as Chunk from "effect/Chunk"
import * as Duration from "effect/Duration"
import * as Schema from "effect/Schema"

export const MyStruct = Schema.Struct({
    optionProp: Schema.Option(Schema.String),
    eitherProp: Schema.Either({ right: Schema.Number, left: Schema.String }),
    pickProp: Schema.Struct({
        a: Schema.String,
        b: Schema.Boolean
    }).pipe(Schema.pick("a")),
    omitProp: Schema.Struct({
        a: Schema.String,
        b: Schema.Boolean
    }).pipe(Schema.omit("b")),
    chunkProp: Schema.Chunk(Schema.String),
    durationProp: Schema.Duration
})

export interface MyStruct {
    optionProp: Option.Option<string>
    eitherProp: Either.Either<number, string>
    pickProp: Pick<{a: string, b: boolean}, "a">
    omitProp: Omit<{a: string, b: boolean}, "b">
    chunkProp: Chunk.Chunk<string>
    durationProp: Duration.Duration
}
"
`;

exports[`Refactor typeToEffectSchema > typeToEffectSchema_indexSignature.ts at 4:21 1`] = `
"// Result of running refactor effect/typeToEffectSchema at position 4:21
import * as Schema from "effect/Schema"

export const MyStruct = Schema.Struct({
    prop: Schema.Literal(42)
}, { key: Schema.Number, value: Schema.String })

export interface MyStruct {
    prop: 42
    [key: number]: string
}
"
`;

exports[`Refactor typeToEffectSchema > typeToEffectSchema_literal.ts at 4:15 1`] = `
"// Result of running refactor effect/typeToEffectSchema at position 4:15
import * as Schema from "effect/Schema"

export const Test = Schema.Literal("a", "b", "c", true, 42)

export type Test = "a" | "b" | "c" | true | 42

export type NoLiteralOptimization = {a: boolean} | "a"
"
`;

exports[`Refactor typeToEffectSchema > typeToEffectSchema_literal.ts at 6:15 1`] = `
"// Result of running refactor effect/typeToEffectSchema at position 6:15
import * as Schema from "effect/Schema"

export type Test = "a" | "b" | "c" | true | 42

export const NoLiteralOptimization = Schema.Union(Schema.Struct({
    a: Schema.Boolean
}), Schema.Literal("a"))

export type NoLiteralOptimization = {a: boolean} | "a"
"
`;

exports[`Refactor typeToEffectSchema > typeToEffectSchema_noGenerics.ts at 3:22 1`] = `
"// Result of running refactor effect/typeToEffectSchema at position 3:22

export interface MyType<A>{
    _A: A
}
"
`;

exports[`Refactor typeToEffectSchema > typeToEffectSchema_typeAlias.ts at 3:15 1`] = `
"// Result of running refactor effect/typeToEffectSchema at position 3:15

export const Test = Schema.Struct({
    a: Schema.String,
    b: Schema.Boolean
});

export type Test = { a: string, b: boolean}
"
`;

exports[`Refactor typeToEffectSchemaClass > typeToEffectSchemaClass.ts at 4:21 1`] = `
"// Result of running refactor effect/typeToEffectSchemaClass at position 4:21
import * as Schema from "effect/Schema"

export class MyStruct extends Schema.Class<MyStruct>("MyStruct")({
    prop: Schema.String
}) { }

export interface MyStruct {
    prop: string
}
"
`;

exports[`Refactor wrapWithEffectGen > wrapWithEffectGen.ts at 5:22 1`] = `
"// Result of running refactor effect/wrapWithEffectGen at position 5:22
import * as Effect from "effect/Effect"
import { pipe } from "effect"

export const test1 = Effect.gen(function*() { return yield* Effect.succeed(42) })

export const test3 = test1

export const test2 = Effect.succeed(42).pipe(
    Effect.map((n) => n + 1),
    Effect.map((n) => n - 1),
)

export const test4 = pipe(
    Effect.succeed(42),
    Effect.map((n) => n + 1),
    Effect.map((n) => n - 1),
)
"
`;

exports[`Refactor wrapWithEffectGen > wrapWithEffectGen.ts at 7:22 1`] = `
"// Result of running refactor effect/wrapWithEffectGen at position 7:22
import * as Effect from "effect/Effect"
import { pipe } from "effect"

export const test1 = Effect.succeed(42)

export const test3 = Effect.gen(function*() { return yield* test1 })

export const test2 = Effect.succeed(42).pipe(
    Effect.map((n) => n + 1),
    Effect.map((n) => n - 1),
)

export const test4 = pipe(
    Effect.succeed(42),
    Effect.map((n) => n + 1),
    Effect.map((n) => n - 1),
)
"
`;

exports[`Refactor wrapWithEffectGen > wrapWithEffectGen.ts at 9:22 1`] = `
"// Result of running refactor effect/wrapWithEffectGen at position 9:22
import * as Effect from "effect/Effect"
import { pipe } from "effect"

export const test1 = Effect.succeed(42)

export const test3 = test1

export const test2 = Effect.gen(function*() { return yield* Effect.succeed(42) }).pipe(
    Effect.map((n) => n + 1),
    Effect.map((n) => n - 1),
)

export const test4 = pipe(
    Effect.succeed(42),
    Effect.map((n) => n + 1),
    Effect.map((n) => n - 1),
)
"
`;

exports[`Refactor wrapWithEffectGen > wrapWithEffectGen.ts at 9:22-12:1 1`] = `
"// Result of running refactor effect/wrapWithEffectGen at position 9:22-12:1
import * as Effect from "effect/Effect"
import { pipe } from "effect"

export const test1 = Effect.succeed(42)

export const test3 = test1

export const test2 = Effect.gen(function*() {
    return yield* Effect.succeed(42).pipe(
        Effect.map((n) => n + 1),
        Effect.map((n) => n - 1)
    )
})

export const test4 = pipe(
    Effect.succeed(42),
    Effect.map((n) => n + 1),
    Effect.map((n) => n - 1),
)
"
`;

exports[`Refactor wrapWithEffectGen > wrapWithEffectGen.ts at 14:22 1`] = `
"// Result of running refactor effect/wrapWithEffectGen at position 14:22
import * as Effect from "effect/Effect"
import { pipe } from "effect"

export const test1 = Effect.succeed(42)

export const test3 = test1

export const test2 = Effect.succeed(42).pipe(
    Effect.map((n) => n + 1),
    Effect.map((n) => n - 1),
)

export const test4 = Effect.gen(function*() {
    return yield* pipe(
        Effect.succeed(42),
        Effect.map((n) => n + 1),
        Effect.map((n) => n - 1)
    )
})
"
`;

exports[`Refactor wrapWithEffectGen > wrapWithEffectGen.ts at 15:5 1`] = `
"// Result of running refactor effect/wrapWithEffectGen at position 15:5
import * as Effect from "effect/Effect"
import { pipe } from "effect"

export const test1 = Effect.succeed(42)

export const test3 = test1

export const test2 = Effect.succeed(42).pipe(
    Effect.map((n) => n + 1),
    Effect.map((n) => n - 1),
)

export const test4 = pipe(
    Effect.gen(function*() { return yield* Effect.succeed(42) }),
    Effect.map((n) => n + 1),
    Effect.map((n) => n - 1),
)
"
`;

exports[`Refactor wrapWithPipe > wrapWithPipe.ts at 2:13-2:26 1`] = `
"// Result of running refactor effect/wrapWithPipe at position 2:13-2:26
const txt = pipe("Hello World")
const txt2 = "Hello"
"
`;

exports[`Refactor wrapWithPipe > wrapWithPipe.ts at 3:14-3:21 1`] = `
"// Result of running refactor effect/wrapWithPipe at position 3:14-3:21
const txt = "Hello World"
const txt2 = pipe("Hello")
"
`;
